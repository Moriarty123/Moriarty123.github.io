---
slug: 响应式原理
title: 响应式原理
---

# Vue3

## vue 响应式原理

### vue2 的响应式原理

vue2 对对象类型的监听是通过 Object.defineProperty 实现的，给想要实现响应式的数据对象每个属性加上 get,set 方法，以实现数据劫持的操作。而对数组类型的监听是通过重写数组的方法实现的。

Object.defineProperty 的定义见这里：[Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

#### 模拟 vue2 响应式实现

```javascript
// 源数据
const person = {
  name: "张三",
  age: 18,
};

let p = {};
Object.defineProperty(p, "name", {
  configurable: true,
  get() {
    console.log("获取了name");
    return person.name;
  },
  set(name) {
    console.log("修改了name"); // 模拟复杂的视图变动的代码
    person.name = name;
  },
});
Object.defineProperty(p, "age", {
  configurable: true,
  get() {
    console.log("获取了age");
    return person.age;
  },
  set(age) {
    console.log("修改了age");
    person.age = age;
  },
});
```

调用结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/de5f5065218e46358cc5acb76f17a2b7.png)

#### 存在问题

1. 对象类型不能监听到新增/删除属性的变动
2. 数组类型不能监听到直接通过下标修改的变动

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4abbc1506b764bf5a78d98306aa439cc.png)
addSex/deleteName/deleteName 点击没反应，但实际数据有修改

针对以上问题，vue2 也提出一些 api 处理：

1. this.$set/Vue.set:修改/新增属性的监听
2. $delete/Vue.delete:删除属性的监听

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c312ba14147a455dbbfe15c6c7f6f66b.png)

所以，虽然 vue2 在响应式数据有些问题，但也提出了解决方案，并不是一无是处。

### vue3 的响应式原理

在说明 vue3 的响应式原理前先了解 window 的两个内置对象
链接在这：
[Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) ：Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。

[Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)：Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。

#### Proxy

vue3 是通过 Proxy 来实现响应式的,大致代码如下：

```javascript
// 源数据
const person = {
  name: "张三",
  age: 18,
  hobby: ["吃饭", "睡觉", "打豆豆"],
};

const p = new Proxy(person, {
  get(target, property, receiver) {
    console.log(`获取了${target}的${property}`);
    return target[property];
  },
  set(target, property, value, receiver) {
    console.log(`修改了${target}的${property}为${value}`);
    target[property] = value;
  },
  deleteProperty(target, property, receiver) {
    return delete target[property];
  },
});
```

target 是源对象, property 是属性, receiver 是代理对象
实际上重写了 Proxy 的 get/set/deleteProperty 方法，实现对对象属性的增删改查

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/16ca530eff0649d7aaab2acf7970cf98.png)

#### Reflect

ECMA 组织正在把 Object 上的一些象 defineProperty()之类的方法有用的方法往 Reflect 上迁移，vue3 响应式实现也用到 Reflect

把上面的代码改造一下：

```javascript
const p = new Proxy(person, {
  get(target, property, receiver) {
    console.log(`获取了${target}的${property}`);
    return Reflect.get(target, property, receiver);
  },
  set(target, property, value, receiver) {
    console.log(`修改了${target}的${property}为${value}`);
    Reflect.set(target, property, value, receiver);
  },
  deleteProperty(target, property) {
    return Reflect.deleteProperty(target, property);
  },
});
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3a8b8a8ec052493b8d89a376591d3cdd.png)

## 组合式 api

### setup()

`setup()` 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：

1. 需要在非单文件组件中使用组合式 API 时。
2. 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。

setup 函数的第一个参数是组件的 props,推荐通过 props.xxx 的形式来使用其中的 props。

setup`函数的第二个参数是一个 Setup 上下文对象,该上下文对象是非响应式的，可以安全地解构

```javascript
export default {
  setup(props, { attrs, slots, emit, expose }) {
    ...
  }
}
```

### 响应式：核心

#### ref()

接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 `.value`。

将内部值转化为 RefImpl 实例对象（Reference Implement 引用实现），

ref()接受的值如果是基本类型，.value 的值是基本类型；接受的值如果是对象, .value 的值是 Proxy 对象，内部实现是'求助'了 reactive()

#### reactive()

返回一个对象的响应式代理。值的类型是 Proxy 类型

##### 与 ref()的区别：

- ref()允许接受基本类型的值和对象，reactive()只能接受对象
- ref()接受对象的内部实现使用了 reactive()
- ref()返回的值使用时需要.value，reactive()不需要

#### readonly()

接受一个对象 (不论是响应式还是普通的) 或是一个 [ref](https://cn.vuejs.org/api/reactivity-core.html#ref)，返回一个原值的只读代理。

用法：避免对一个对象进行修改，特别是一些三方库方法的调用，可以避免一些麻烦。

#### computed()

接受一个 [getter 函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description)，返回一个只读的响应式 [ref](https://cn.vuejs.org/api/reactivity-core.html#ref) 对象。该 ref 通过 `.value` 暴露 getter 函数的返回值。它也可以接受一个带有 `get` 和 `set` 函数的对象来创建一个可写的 ref 对象。

正常用法

```javascript
const plusOne = computed(() => count.value + 1);
```

可变 ref 对象

如果是在模板中使用，会调用 get()，展示的值为 2,这里不推荐这样使用，仅供参考

```javascript
const count = ref(1);
const plusOne = computed({
  get: () => count.value + 1,
  set: (val) => {
    count.value = val - 1;
  },
});

plusOne.value = 1;
console.log(count.value); // 0
```

#### watch()

侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。

`watch()` 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。

第一个参数是侦听器的**源**。这个来源可以是以下几种：

- 一个函数，返回一个值
- 一个 ref
- 一个响应式对象
- ...或是由以上类型的值组成的数组

第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。

当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。

第三个可选的参数是一个对象，支持以下这些选项：

- **`immediate`**：在侦听器创建时立即触发回调。第一次调用时旧值是 `undefined`。
- **`deep`**：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。参考[深层侦听器](https://cn.vuejs.org/guide/essentials/watchers.html#deep-watchers)。
- **`flush`**：调整回调函数的刷新时机。
- **`onTrack / onTrigger`**：调试侦听器的依赖。参考[调试侦听器](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#watcher-debugging)。
- **`once`**：回调函数只会运行一次。侦听器将在回调函数首次运行后自动停止。

##### 存在的问题

- 使用 `{ deep: true }` 强制侦听器进入深层级模式。在深层级模式时，如果回调函数由于深层级的变更而被触发，那么新值和旧值将是同一个对象

- 如果监听的是 reactive()返回的对象，侦听器会自动启用深层模式

##### 监听的几种场景：

```javascript
const age = ref(20);
const car = ref({ name: "奔驰", price: 40 });
let person = reactive({ age: 18, job: { j1: { money: 20 } } });

// 监听ref
watch(age, (newValue, oldValue) => {
  console.log("监听ref");
  console.log(newValue, oldValue);
});

// 监听ref的属性
watch(
  () => car.value.price,
  (newValue, oldValue) => {
    console.log("监听ref的属性");
    console.log(newValue, oldValue);
  }
);

// 监听数组
watch([() => car.value.price, () => car.value.name], (newValue, oldValue) => {
  console.log("监听数组");
  console.log(newValue, oldValue);
});

// 监听reactive
watch(person, (newValue, oldValue) => {
  console.log("监听reactive");
  console.log(newValue, oldValue);
});
```

#### watchEffect()

立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。

##### 与 watch 的区别：

- watch 强调属性的监听，watchEffect 强调属性之间的关系，自动监听用到的属性
- watch 是是懒监听，watchEffect 初始化后收集依赖

##### 与 computed 的区别：

watchEffect 强调过程，回调函数可以执行一些方法，computed 更注重产生的值

### 响应式：工具

#### isRef()

检查某个值是否为 ref。返回值是一个[类型判定](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) (type predicate)，这意味着 `isRef` 可以被用作类型守卫，即可以用来判断变量是否可缩小到更具体的类型。

以下几个函数类有类型作用：isReactive()/isReadonly()/isProxy()

#### unref()

`val = isRef(val) ? val.value : val` 计算的一个语法糖

#### toRef()

可以将值、refs 或 getters 规范化为 refs

用法：为响应式对象属性创建一个‘别名’

// 双向 ref，会与源属性同步 const fooRef = toRef(state, 'foo')

fooRef.value ++ 与 state.value.foo 等价

#### toRefs()

将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 [`toRef()`](https://cn.vuejs.org/api/reactivity-utilities.html#toref) 创建的。

用法：其中 foo/bar 不会丢失响应式，适合用于响应式对象的解构赋值

![image-20240712000315368](C:\Users\tyt\AppData\Roaming\Typora\typora-user-images\image-20240712000315368.png)

### 响应式：进阶

#### toRaw()

根据一个 Vue 创建的代理返回其原始对象。可以返回由 [`reactive()`](https://cn.vuejs.org/api/reactivity-core.html#reactive)、[`readonly()`](https://cn.vuejs.org/api/reactivity-core.html#readonly)、[`shallowReactive()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive) 或者 [`shallowReadonly()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreadonly) 创建的代理对应的原始对象。

```javascript
const person = {
  name: "张三",
  age: 18,
  car: { name: "奔驰", price: 40 },
};

const p1 = reactive(person);

const p2 = readonly(person);

const p3 = shallowReactive(person);

const p4 = shallowReadonly(person);

const p5 = toRaw(p1);

console.log(p1);
console.log(p2);
console.log(p3);
console.log(p4);
console.log(p5);
```

![image-20240712002305520](C:\Users\tyt\AppData\Roaming\Typora\typora-user-images\image-20240712002305520.png)

#### markRaw()

将一个对象标记为不可被转为代理。返回该对象本身。可以用于响应式对象的复杂对象属性，这个属性一般是不可变的，取消响应式可提高效率

例子：

car 这个属性是不应该变动的，即使修改内部属性，也不会在界面上响应，但实际上数据已经进行了修改。

```javascript
<template>
  <h1>name: {{ person.name }}</h1>
  <h2>age: {{ person.age }}</h2>
  <h3>car: {{ person.car }}</h3>
  <button @click="addCar">添加车辆</button>
  <button @click="changePrice">车辆涨价</button>
</template>

<script>
import { markRaw, reactive } from "vue";
export default {
  setup() {
    const person = reactive({
      name: "张三",
      age: 18,
    });

    const addCar = () => {
      person.car = markRaw({ car: "奔驰", price: 40 });
    };

    const changePrice = () => {
      person.car.price += 10;
      console.log(person.car.price);
    };

    return {
      person,
      addCar,
      changePrice,
    };
  },
};
</script>

<style></style>

```

#### customRef()

创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式

类型

```javascript
function customRef<T>(factory: CustomRefFactory<T>): Ref<T>

type CustomRefFactory<T> = (
  track: () => void,
  trigger: () => void
) => {
  get: () => T
  set: (value: T) => void
}

```

`customRef()` 预期接收一个工厂函数作为参数，这个工厂函数接受 `track` 和 `trigger` 两个函数作为参数，并返回一个带有 `get` 和 `set` 方法的对象。

一般来说，`track()` 应该在 `get()` 方法中调用，而 `trigger()` 应该在 `set()` 中调用。然而事实上，你对何时调用、是否应该调用他们有完全的控制权。

例子：通过 customRef 实现防抖响应式

创建一个 hook

```javascript
import { customRef } from "vue";

export function useDebouncedRef(value, delay = 200) {
  let timeout;
  return customRef((track, trigger) => {
    return {
      get() {
        track(); // 触发依赖追踪
        return value;
      },
      set(newValue) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          value = newValue;
          trigger(); // 更新触发，通知模板进行重新渲染
        }, delay);
      },
    };
  });
}
```

在模板中使用

```html
<template>
  <input v-model="text" />
  <div>{{ text }}</div>
</template>

<script setup>
  import { useDebouncedRef } from "./hooks/debouncedRef";
  const text = useDebouncedRef("hello");
</script>
```

customRef()中需要实现 get/set 方法来实现响应式，在 set()方法中，定义一个定时器 timeout，延时 delay 给 value 赋值，然后触发更新方法 trigger();在模板中会调用 get()方法，触发依赖追踪函数 track(),实现延迟响应的效果。
